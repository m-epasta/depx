use std::collections::{HashMap, HashSet};

use miette::{Context, IntoDiagnostic, Result};
use serde::Deserialize;

use crate::types::{DeprecatedPackage, Package, Severity, Vulnerability};

/// Check for known vulnerabilities in packages
/// Now properly filters by installed version using OSV's version-aware query
pub async fn check_vulnerabilities(
    packages: &HashMap<String, Package>,
    used_packages: Option<&HashSet<String>>,
) -> Result<Vec<Vulnerability>> {
    let mut vulnerabilities = Vec::new();
    let client = reqwest::Client::new();

    // Query OSV for each package with its specific version
    for (name, pkg) in packages {
        let vulns = query_osv_with_version(&client, name, &pkg.version).await?;

        for mut vuln in vulns {
            // Mark if it affects used code
            vuln.affects_used_code = used_packages
                .map(|used| used.contains(&vuln.package_name))
                .unwrap_or(true);

            vulnerabilities.push(vuln);
        }
    }

    // Sort by severity (critical first), then by package name
    vulnerabilities.sort_by(|a, b| {
        b.severity
            .cmp(&a.severity)
            .then_with(|| a.package_name.cmp(&b.package_name))
    });

    Ok(vulnerabilities)
}

/// Check for deprecated packages
pub async fn check_deprecated(packages: &HashMap<String, Package>) -> Result<Vec<DeprecatedPackage>> {
    let mut deprecated = Vec::new();

    for (_name, pkg) in packages {
        if let Some(ref message) = pkg.deprecated {
            deprecated.push(DeprecatedPackage {
                package: pkg.clone(),
                message: message.clone(),
                is_used: false,
            });
        }
    }

    deprecated.sort_by(|a, b| a.package.name.cmp(&b.package.name));

    Ok(deprecated)
}

/// Query OSV with specific version - only returns vulns affecting that version
async fn query_osv_with_version(
    client: &reqwest::Client,
    package_name: &str,
    version: &str,
) -> Result<Vec<Vulnerability>> {
    // OSV API supports version in query - it filters server-side!
    let request = OsvQueryRequest {
        package: OsvPackage {
            name: package_name.to_string(),
            ecosystem: "npm".to_string(),
        },
        version: Some(version.to_string()),
    };

    let response = client
        .post("https://api.osv.dev/v1/query")
        .json(&request)
        .send()
        .await
        .into_diagnostic()
        .with_context(|| format!("Failed to query OSV for {}", package_name))?;

    if !response.status().is_success() {
        return Ok(Vec::new());
    }

    let osv_response: OsvQueryResponse = response
        .json()
        .await
        .into_diagnostic()
        .with_context(|| format!("Failed to parse OSV response for {}", package_name))?;

    let vulns = osv_response
        .vulns
        .into_iter()
        .filter_map(|v| convert_osv_vuln(v, package_name, version))
        .collect();

    Ok(vulns)
}

fn convert_osv_vuln(osv: OsvVulnerability, package_name: &str, version: &str) -> Option<Vulnerability> {
    // Determine severity from CVSS score or database_specific
    let severity = determine_severity(&osv);

    // Find the affected entry for this package
    let affected = osv.affected.iter().find(|a| {
        a.package
            .as_ref()
            .map(|p| p.name == package_name)
            .unwrap_or(false)
    })?;

    // Build vulnerable range description
    let vulnerable_range = build_vulnerable_range(affected);

    // Find patched version
    let patched_version = find_patched_version(affected);

    Some(Vulnerability {
        id: osv.id,
        title: osv.summary.unwrap_or_else(|| "Unknown vulnerability".to_string()),
        severity,
        package_name: package_name.to_string(),
        vulnerable_range,
        patched_version,
        url: osv.references.first().map(|r| r.url.clone()),
        affects_used_code: false,
        installed_version: version.to_string(),
    })
}

fn determine_severity(osv: &OsvVulnerability) -> Severity {
    // Try CVSS score first
    if let Some(severity_info) = osv.severity.first() {
        if let Ok(score) = severity_info.score.parse::<f32>() {
            return match score {
                s if s >= 9.0 => Severity::Critical,
                s if s >= 7.0 => Severity::High,
                s if s >= 4.0 => Severity::Medium,
                _ => Severity::Low,
            };
        }
    }

    // Try database_specific severity
    if let Some(ref db) = osv.database_specific {
        if let Some(ref sev) = db.severity {
            return match sev.to_lowercase().as_str() {
                "critical" => Severity::Critical,
                "high" => Severity::High,
                "moderate" | "medium" => Severity::Medium,
                "low" => Severity::Low,
                _ => Severity::Medium,
            };
        }
    }

    Severity::Medium
}

fn build_vulnerable_range(affected: &OsvAffected) -> String {
    let mut ranges = Vec::new();

    for range in &affected.ranges {
        let mut introduced = None;
        let mut fixed = None;

        for event in &range.events {
            if event.introduced.is_some() {
                introduced = event.introduced.as_ref();
            }
            if event.fixed.is_some() {
                fixed = event.fixed.as_ref();
            }
        }

        let range_str = match (introduced, fixed) {
            (Some(i), Some(f)) => format!(">={}, <{}", i, f),
            (Some(i), None) => format!(">={}", i),
            (None, Some(f)) => format!("<{}", f),
            (None, None) => "*".to_string(),
        };

        if range_str != "*" {
            ranges.push(range_str);
        }
    }

    if ranges.is_empty() {
        "*".to_string()
    } else {
        ranges.join(" || ")
    }
}

fn find_patched_version(affected: &OsvAffected) -> Option<String> {
    for range in &affected.ranges {
        for event in &range.events {
            if let Some(ref fixed) = event.fixed {
                return Some(fixed.clone());
            }
        }
    }
    None
}

// OSV API types

#[derive(serde::Serialize)]
struct OsvQueryRequest {
    package: OsvPackage,
    #[serde(skip_serializing_if = "Option::is_none")]
    version: Option<String>,
}

#[derive(serde::Serialize)]
struct OsvPackage {
    name: String,
    ecosystem: String,
}

#[derive(Deserialize, Default)]
struct OsvQueryResponse {
    #[serde(default)]
    vulns: Vec<OsvVulnerability>,
}

#[derive(Deserialize)]
struct OsvVulnerability {
    id: String,
    summary: Option<String>,
    #[serde(default)]
    severity: Vec<OsvSeverity>,
    #[serde(default)]
    affected: Vec<OsvAffected>,
    #[serde(default)]
    references: Vec<OsvReference>,
    database_specific: Option<OsvDatabaseSpecific>,
}

#[derive(Deserialize)]
struct OsvSeverity {
    #[serde(rename = "type")]
    _severity_type: String,
    score: String,
}

#[derive(Deserialize)]
struct OsvAffected {
    package: Option<OsvAffectedPackage>,
    #[serde(default)]
    ranges: Vec<OsvRange>,
}

#[derive(Deserialize)]
struct OsvAffectedPackage {
    name: String,
}

#[derive(Deserialize)]
struct OsvRange {
    #[serde(rename = "type")]
    _range_type: String,
    #[serde(default)]
    events: Vec<OsvEvent>,
}

#[derive(Deserialize)]
struct OsvEvent {
    introduced: Option<String>,
    fixed: Option<String>,
}

#[derive(Deserialize)]
struct OsvReference {
    url: String,
}

#[derive(Deserialize)]
struct OsvDatabaseSpecific {
    severity: Option<String>,
}
