use std::collections::{HashMap, HashSet};

use miette::{Context, IntoDiagnostic, Result};
use serde::Deserialize;

use crate::types::{DeprecatedPackage, Package, Severity, Vulnerability};

/// Batch size for OSV querybatch API
const BATCH_SIZE: usize = 1000;

/// Check for known vulnerabilities in packages using OSV querybatch API
/// Groups packages into batches for efficient querying
pub async fn check_vulnerabilities(
    packages: &HashMap<String, Package>,
    used_packages: Option<&HashSet<String>>,
) -> Result<Vec<Vulnerability>> {
    let client = reqwest::Client::new();
    let total_packages = packages.len();

    if total_packages == 0 {
        return Ok(Vec::new());
    }

    // Convert to vec for batching
    let packages_vec: Vec<(&String, &Package)> = packages.iter().collect();
    let total_batches = (total_packages + BATCH_SIZE - 1) / BATCH_SIZE;

    // Show progress for large projects
    if total_packages > BATCH_SIZE {
        eprintln!(
            "\x1b[1;36m        Info\x1b[0m Scanning {} packages in {} batches...",
            total_packages, total_batches
        );
    }

    // Step 1: Query all packages in batches to get vulnerability IDs
    let mut package_vuln_ids: HashMap<String, Vec<(String, String)>> = HashMap::new(); // package_name -> [(vuln_id, version)]

    for (batch_idx, chunk) in packages_vec.chunks(BATCH_SIZE).enumerate() {
        if total_batches > 1 {
            eprint!(
                "\r\x1b[1;36m    Scanning\x1b[0m batch {}/{}...",
                batch_idx + 1,
                total_batches
            );
        }

        match query_batch(&client, chunk).await {
            Ok(batch_results) => {
                for (i, result) in batch_results.into_iter().enumerate() {
                    if !result.vulns.is_empty() {
                        let (pkg_name, pkg) = chunk[i];
                        let vuln_ids: Vec<(String, String)> = result
                            .vulns
                            .into_iter()
                            .map(|v| (v.id, pkg.version.clone()))
                            .collect();
                        package_vuln_ids.insert(pkg_name.clone(), vuln_ids);
                    }
                }
            }
            Err(e) => {
                // Log error but continue with other batches
                eprintln!(
                    "\n\x1b[1;33m     Warning\x1b[0m Batch {} failed: {}",
                    batch_idx + 1,
                    e
                );
            }
        }
    }

    if total_batches > 1 {
        eprintln!(); // New line after progress
    }

    // Step 2: Collect unique vulnerability IDs
    let unique_vuln_ids: HashSet<String> = package_vuln_ids
        .values()
        .flat_map(|ids| ids.iter().map(|(id, _)| id.clone()))
        .collect();

    if unique_vuln_ids.is_empty() {
        return Ok(Vec::new());
    }

    // Step 3: Fetch full details for each unique vulnerability
    if unique_vuln_ids.len() > 10 {
        eprintln!(
            "\x1b[1;36m        Info\x1b[0m Fetching details for {} vulnerabilities...",
            unique_vuln_ids.len()
        );
    }

    let vuln_details = fetch_vulnerability_details(&client, &unique_vuln_ids).await?;

    // Step 4: Build final vulnerability list with package mapping
    let mut vulnerabilities = Vec::new();

    for (pkg_name, vuln_ids) in &package_vuln_ids {
        for (vuln_id, version) in vuln_ids {
            if let Some(osv_vuln) = vuln_details.get(vuln_id) {
                if let Some(mut vuln) = convert_osv_vuln(osv_vuln, pkg_name, version) {
                    vuln.affects_used_code = used_packages
                        .map(|used| used.contains(pkg_name))
                        .unwrap_or(true);
                    vulnerabilities.push(vuln);
                }
            }
        }
    }

    // Sort by severity (critical first), then by package name
    vulnerabilities.sort_by(|a, b| {
        b.severity
            .cmp(&a.severity)
            .then_with(|| a.package_name.cmp(&b.package_name))
    });

    Ok(vulnerabilities)
}

/// Query a batch of packages using OSV querybatch API
async fn query_batch(
    client: &reqwest::Client,
    packages: &[(&String, &Package)],
) -> Result<Vec<OsvBatchResult>> {
    let queries: Vec<OsvQueryRequest> = packages
        .iter()
        .map(|(name, pkg)| OsvQueryRequest {
            package: OsvPackage {
                name: (*name).clone(),
                ecosystem: "npm".to_string(),
            },
            version: Some(pkg.version.clone()),
        })
        .collect();

    let request = OsvBatchRequest { queries };

    let response = client
        .post("https://api.osv.dev/v1/querybatch")
        .json(&request)
        .send()
        .await
        .into_diagnostic()
        .with_context(|| "Failed to query OSV batch API")?;

    if !response.status().is_success() {
        let status = response.status();
        let body = response.text().await.unwrap_or_default();
        miette::bail!("OSV API returned {}: {}", status, body);
    }

    let batch_response: OsvBatchResponse = response
        .json()
        .await
        .into_diagnostic()
        .with_context(|| "Failed to parse OSV batch response")?;

    Ok(batch_response.results)
}

/// Fetch full vulnerability details for a set of IDs
/// Uses concurrent requests for efficiency
async fn fetch_vulnerability_details(
    client: &reqwest::Client,
    vuln_ids: &HashSet<String>,
) -> Result<HashMap<String, OsvVulnerability>> {
    use tokio::task::JoinSet;

    let mut details = HashMap::new();
    let mut join_set = JoinSet::new();

    // Limit concurrent requests to avoid overwhelming the API
    const MAX_CONCURRENT: usize = 50;
    let vuln_ids_vec: Vec<String> = vuln_ids.iter().cloned().collect();

    for chunk in vuln_ids_vec.chunks(MAX_CONCURRENT) {
        for vuln_id in chunk {
            let client = client.clone();
            let id = vuln_id.clone();
            join_set.spawn(async move {
                let result = fetch_single_vulnerability(&client, &id).await;
                (id, result)
            });
        }

        // Wait for this batch to complete before starting next
        while let Some(result) = join_set.join_next().await {
            if let Ok((id, Ok(vuln))) = result {
                details.insert(id, vuln);
            }
        }
    }

    Ok(details)
}

/// Fetch a single vulnerability by ID
async fn fetch_single_vulnerability(
    client: &reqwest::Client,
    vuln_id: &str,
) -> Result<OsvVulnerability> {
    let url = format!("https://api.osv.dev/v1/vulns/{}", vuln_id);

    let response = client
        .get(&url)
        .send()
        .await
        .into_diagnostic()
        .with_context(|| format!("Failed to fetch vulnerability {}", vuln_id))?;

    if !response.status().is_success() {
        miette::bail!("Failed to fetch vulnerability {}", vuln_id);
    }

    response
        .json()
        .await
        .into_diagnostic()
        .with_context(|| format!("Failed to parse vulnerability {}", vuln_id))
}

/// Check for deprecated packages
pub async fn check_deprecated(
    packages: &HashMap<String, Package>,
) -> Result<Vec<DeprecatedPackage>> {
    let mut deprecated = Vec::new();

    for (_name, pkg) in packages {
        if let Some(ref message) = pkg.deprecated {
            deprecated.push(DeprecatedPackage {
                package: pkg.clone(),
                message: message.clone(),
                is_used: false,
            });
        }
    }

    deprecated.sort_by(|a, b| a.package.name.cmp(&b.package.name));

    Ok(deprecated)
}

fn convert_osv_vuln(
    osv: &OsvVulnerability,
    package_name: &str,
    version: &str,
) -> Option<Vulnerability> {
    // Determine severity from CVSS score or database_specific
    let severity = determine_severity(osv);

    // Find the affected entry for this package
    let affected = osv.affected.iter().find(|a| {
        a.package
            .as_ref()
            .map(|p| p.name == package_name)
            .unwrap_or(false)
    })?;

    // Build vulnerable range description
    let vulnerable_range = build_vulnerable_range(affected);

    // Find patched version
    let patched_version = find_patched_version(affected);

    Some(Vulnerability {
        id: osv.id.clone(),
        title: osv
            .summary
            .clone()
            .unwrap_or_else(|| "Unknown vulnerability".to_string()),
        severity,
        package_name: package_name.to_string(),
        vulnerable_range,
        patched_version,
        url: osv.references.first().map(|r| r.url.clone()),
        affects_used_code: false,
        installed_version: version.to_string(),
    })
}

fn determine_severity(osv: &OsvVulnerability) -> Severity {
    // Try CVSS score first
    if let Some(severity_info) = osv.severity.first() {
        if let Ok(score) = severity_info.score.parse::<f32>() {
            return match score {
                s if s >= 9.0 => Severity::Critical,
                s if s >= 7.0 => Severity::High,
                s if s >= 4.0 => Severity::Medium,
                _ => Severity::Low,
            };
        }
    }

    // Try database_specific severity
    if let Some(ref db) = osv.database_specific {
        if let Some(ref sev) = db.severity {
            return match sev.to_lowercase().as_str() {
                "critical" => Severity::Critical,
                "high" => Severity::High,
                "moderate" | "medium" => Severity::Medium,
                "low" => Severity::Low,
                _ => Severity::Medium,
            };
        }
    }

    Severity::Medium
}

fn build_vulnerable_range(affected: &OsvAffected) -> String {
    let mut ranges = Vec::new();

    for range in &affected.ranges {
        let mut introduced = None;
        let mut fixed = None;

        for event in &range.events {
            if event.introduced.is_some() {
                introduced = event.introduced.as_ref();
            }
            if event.fixed.is_some() {
                fixed = event.fixed.as_ref();
            }
        }

        let range_str = match (introduced, fixed) {
            (Some(i), Some(f)) => format!(">={}, <{}", i, f),
            (Some(i), None) => format!(">={}", i),
            (None, Some(f)) => format!("<{}", f),
            (None, None) => "*".to_string(),
        };

        if range_str != "*" {
            ranges.push(range_str);
        }
    }

    if ranges.is_empty() {
        "*".to_string()
    } else {
        ranges.join(" || ")
    }
}

fn find_patched_version(affected: &OsvAffected) -> Option<String> {
    for range in &affected.ranges {
        for event in &range.events {
            if let Some(ref fixed) = event.fixed {
                return Some(fixed.clone());
            }
        }
    }
    None
}

// OSV API types

#[derive(serde::Serialize)]
struct OsvBatchRequest {
    queries: Vec<OsvQueryRequest>,
}

#[derive(serde::Serialize)]
struct OsvQueryRequest {
    package: OsvPackage,
    #[serde(skip_serializing_if = "Option::is_none")]
    version: Option<String>,
}

#[derive(serde::Serialize)]
struct OsvPackage {
    name: String,
    ecosystem: String,
}

#[derive(Deserialize, Default)]
struct OsvBatchResponse {
    #[serde(default)]
    results: Vec<OsvBatchResult>,
}

#[derive(Deserialize, Default)]
struct OsvBatchResult {
    #[serde(default)]
    vulns: Vec<OsvBatchVuln>,
}

#[derive(Deserialize)]
struct OsvBatchVuln {
    id: String,
    #[allow(dead_code)]
    modified: Option<String>,
}

#[derive(Deserialize, Clone)]
struct OsvVulnerability {
    id: String,
    summary: Option<String>,
    #[serde(default)]
    severity: Vec<OsvSeverity>,
    #[serde(default)]
    affected: Vec<OsvAffected>,
    #[serde(default)]
    references: Vec<OsvReference>,
    database_specific: Option<OsvDatabaseSpecific>,
}

#[derive(Deserialize, Clone)]
struct OsvSeverity {
    #[serde(rename = "type")]
    _severity_type: String,
    score: String,
}

#[derive(Deserialize, Clone)]
struct OsvAffected {
    package: Option<OsvAffectedPackage>,
    #[serde(default)]
    ranges: Vec<OsvRange>,
}

#[derive(Deserialize, Clone)]
struct OsvAffectedPackage {
    name: String,
}

#[derive(Deserialize, Clone)]
struct OsvRange {
    #[serde(rename = "type")]
    _range_type: String,
    #[serde(default)]
    events: Vec<OsvEvent>,
}

#[derive(Deserialize, Clone)]
struct OsvEvent {
    introduced: Option<String>,
    fixed: Option<String>,
}

#[derive(Deserialize, Clone)]
struct OsvReference {
    url: String,
}

#[derive(Deserialize, Clone)]
struct OsvDatabaseSpecific {
    severity: Option<String>,
}
